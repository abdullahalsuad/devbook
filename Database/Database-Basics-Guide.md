# Part 01 ( Database Basics Guide)

---

## **1. VARIOUS KEYS IN DATABASE**

### **What are Keys?**

Keys are special columns (or combinations of columns) that help identify records uniquely and create relationships between tables. Think of them as unique identifiers, like your passport number or student ID.

### **Types of Keys:**

#### **a) Primary Key**

- **Definition:** A column (or set of columns) that uniquely identifies each row in a table
- **Rules:**
  - Must contain UNIQUE values
  - Cannot contain NULL values
  - Only ONE primary key per table
  - Cannot be changed once set

**Example:**

```sql
CREATE TABLE Students (
    student_id INT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100)
);
```

**Real-life analogy:** Like your national ID number - unique to you, never changes, and never empty.

---

#### **b) Foreign Key**

- **Definition:** A column that creates a link between two tables
- **Purpose:** Maintains referential integrity (keeps data consistent between tables)
- **Rules:**
  - References a PRIMARY KEY in another table
  - CAN contain NULL values
  - CAN have duplicate values
  - Can have multiple foreign keys in one table

**Example:**

```sql
CREATE TABLE Orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    FOREIGN KEY (customer_id) REFERENCES Customers(customer_id)
);
```

**Real-life analogy:** Like having your parent's phone number in your school records - it connects you to your parent's information.

---

#### **c) Unique Key**

- **Definition:** Ensures all values in a column are different
- **Rules:**
  - Must contain UNIQUE values
  - CAN contain ONE NULL value
  - Can have MULTIPLE unique keys per table

**Example:**

```sql
CREATE TABLE Users (
    user_id INT PRIMARY KEY,
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(15) UNIQUE
);
```

**Difference from Primary Key:**

- Primary Key: NO nulls, only ONE per table
- Unique Key: ONE null allowed, MULTIPLE per table

---

#### **d) Candidate Key**

- **Definition:** A Candidate Key is a minimal set of one or more attributes (columns) in a database table that uniquely identifies each record in that table.
- **Characteristics:** Unique,Not Null and minimal (no unnecessary columns)

**Example:**
In a Students table:

- student_id (unique)
- email (unique)
- passport_number (unique)

All three are candidate keys. You choose ONE as the primary key; the others remain candidate keys.

---

#### **e) Alternate Key**

- **Definition:** Candidate keys that were NOT chosen as the primary key

**Example:**
If you chose `student_id` as PRIMARY KEY, then `email` and `passport_number` become ALTERNATE KEYS.

---

#### **f) Composite Key**

- **Definition:** A primary key made up of TWO or more columns together
- **When to use:** When no single column can uniquely identify a row

**Example:**

```sql
CREATE TABLE Enrollments (
    student_id INT,
    course_id INT,
    enrollment_date DATE,
    PRIMARY KEY (student_id, course_id)
);
```

Here, `student_id` alone isn't unique (one student takes many courses), and `course_id` alone isn't unique (one course has many students). Together, they're unique.

---

#### **g) Super Key**

- **Definition:** Any combination of columns that can uniquely identify a row
- **Note:** Includes extra unnecessary columns 

**Example:**
In Students table:

- student_id (minimal, good)
- student_id + name (works but name is unnecessary)
- student_id + name + email (works but extra columns)

All are super keys, but only the first is a candidate key (minimal).

---

#### **h) Surrogate Key**

- **Definition:** An artificial key with no business meaning, usually auto-generated
- **Purpose:** Simple, consistent identification

**Example:**

```sql
CREATE TABLE Products (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    product_name VARCHAR(100),
    barcode VARCHAR(50)
);
```

`product_id` has no real-world meaning; it's just a number generated by the database.

---

#### **i) Natural Key**

- **Definition:** A key that has business meaning (comes from real-world data)

**Examples:**

- Social Security Number
- ISBN (for books)
- Email address
- Vehicle License Plate

**Natural vs Surrogate:**

- Natural Key: `email` (has meaning)
- Surrogate Key: `user_id` (just a number)

**Best Practice:** Often use surrogate keys as primary keys because natural keys can change or have format issues.

---

### **Quick Comparison Table:**

| Key Type      | Unique? | Null Allowed? | How Many?              | Purpose                |
| ------------- | ------- | ------------- | ---------------------- | ---------------------- |
| Primary Key   | Yes     | No            | One per table          | Main identifier        |
| Foreign Key   | No      | Yes           | Multiple               | Links tables           |
| Unique Key    | Yes     | One null      | Multiple               | Enforce uniqueness     |
| Candidate Key | Yes     | No            | Multiple               | Potential primary keys |
| Composite Key | Yes     | No            | One (but multi-column) | Combined identifier    |
| Surrogate Key | Yes     | No            | One                    | Artificial ID          |
| Natural Key   | Yes     | Depends       | Varies                 | Real-world identifier  |

---

## **2. DATA TYPES**

### **What are Data Types?**

Data types define what kind of data a column can store. Choosing the right data type is crucial for:

- **Performance:** Correct types use less storage and process faster
- **Data Integrity:** Prevents storing wrong data (like text in a number field)
- **Clarity:** Makes the database structure understandable

---

### **Categories of Data Types:**

### **A) NUMERIC DATA TYPES**

#### **1. Integer Types (Whole Numbers)**

| Type          | Storage | Range                                       | Use Case                |
| ------------- | ------- | ------------------------------------------- | ----------------------- |
| **TINYINT**   | 1 byte  | -128 to 127 (signed)<br>0 to 255 (unsigned) | Age, small counts       |
| **SMALLINT**  | 2 bytes | -32,768 to 32,767                           | Small numbers           |
| **MEDIUMINT** | 3 bytes | -8,388,608 to 8,388,607                     | Medium numbers          |
| **INT**       | 4 bytes | -2 billion to 2 billion                     | Most common integer use |
| **BIGINT**    | 8 bytes | -9 quintillion to 9 quintillion             | Very large numbers, IDs |

**Examples:**

```sql
CREATE TABLE Products (
    product_id INT,
    quantity SMALLINT,
    views BIGINT,
    stock_level TINYINT
);
```

---

#### **2. Decimal Types (Numbers with Decimals)**

| Type             | Description                                                     | Use Case                  |
| ---------------- | --------------------------------------------------------------- | ------------------------- |
| **DECIMAL(p,s)** | Fixed precision<br>p = total digits<br>s = digits after decimal | Money, exact calculations |
| **NUMERIC**      | Same as DECIMAL                                                 | Financial data            |
| **FLOAT**        | Approximate, 4 bytes                                            | Scientific calculations   |
| **DOUBLE**       | Approximate, 8 bytes                                            | High-precision science    |

**Examples:**

```sql
CREATE TABLE Orders (
    order_id INT,
    total_amount DECIMAL(10,2),  -- 10 digits total, 2 after decimal
    tax_rate DECIMAL(5,4),       -- 5 digits total, 4 after decimal
    weight FLOAT
);

-- Examples of values:
-- total_amount: 12345678.90 ✓  123456789.00 ✗ (too many digits)
-- tax_rate: 0.0825 ✓
```

**DECIMAL vs FLOAT:**

- **DECIMAL:** Exact values (use for money)
- **FLOAT/DOUBLE:** Approximate values (use for measurements, science)

---

### **B) STRING/CHARACTER DATA TYPES**

#### **1. Fixed vs Variable Length**

| Type           | Description     | Max Length | Use Case                 |
| -------------- | --------------- | ---------- | ------------------------ |
| **CHAR(n)**    | Fixed length    | 255        | Country codes (US, BD)   |
| **VARCHAR(n)** | Variable length | 65,535     | Names, emails, addresses |

**Key Difference:**

```sql
-- CHAR(10):
'Hello'     → stored as 'Hello     ' (padded with spaces)

-- VARCHAR(10):
'Hello'     → stored as 'Hello' (no padding, saves space)
```

**Examples:**

```sql
CREATE TABLE Users (
    user_id INT,
    username VARCHAR(50),      -- Variable: saves space
    country_code CHAR(2),      -- Fixed: always 2 letters (BD, US)
    postal_code CHAR(4)        -- Fixed: always 4 digits in Bangladesh
);
```

---

#### **2. Large Text Types**

| Type           | Max Size     | Use Case               |
| -------------- | ------------ | ---------------------- |
| **TEXT**       | 65,535 chars | Articles, descriptions |
| **MEDIUMTEXT** | 16 MB        | Long documents         |
| **LONGTEXT**   | 4 GB         | Books, huge content    |

**Example:**

```sql
CREATE TABLE BlogPosts (
    post_id INT PRIMARY KEY,
    title VARCHAR(200),
    summary TEXT,              -- Short description
    content LONGTEXT           -- Full article
);
```

---

### **C) DATE AND TIME DATA TYPES**

| Type          | Format              | Range                    | Use Case                |
| ------------- | ------------------- | ------------------------ | ----------------------- |
| **DATE**      | YYYY-MM-DD          | 1000-01-01 to 9999-12-31 | Birth dates, deadlines  |
| **TIME**      | HH:MM:SS            | -838:59:59 to 838:59:59  | Duration, time of day   |
| **DATETIME**  | YYYY-MM-DD HH:MM:SS | 1000-01-01 to 9999-12-31 | Event timestamps        |
| **TIMESTAMP** | YYYY-MM-DD HH:MM:SS | 1970-01-01 to 2038-01-19 | Auto-updated timestamps |
| **YEAR**      | YYYY                | 1901 to 2155             | Year only               |

**Examples:**

```sql
CREATE TABLE Events (
    event_id INT,
    event_date DATE,                    -- 2025-12-04
    event_time TIME,                    -- 14:30:00
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- Auto-set
    updated_at DATETIME                 -- Manually set
);

-- Inserting data:
INSERT INTO Events (event_date, event_time, updated_at)
VALUES ('2025-12-25', '09:00:00', '2025-12-04 14:35:22');
```

**DATETIME vs TIMESTAMP:**

- **DATETIME:** Manual control, wider range
- **TIMESTAMP:** Auto-updates, timezone aware, smaller range

---

### **D) BOOLEAN DATA TYPE**

| Type                    | Values              | Storage |
| ----------------------- | ------------------- | ------- |
| **BOOLEAN** or **BOOL** | TRUE (1), FALSE (0) | 1 byte  |

**Examples:**

```sql
CREATE TABLE Users (
    user_id INT,
    is_active BOOLEAN DEFAULT TRUE,
    is_verified BOOL DEFAULT FALSE,
    email_notifications BOOLEAN
);

-- Inserting data:
INSERT INTO Users (user_id, is_active, is_verified)
VALUES (1, TRUE, FALSE);

-- Querying:
SELECT * FROM Users WHERE is_active = TRUE;
SELECT * FROM Users WHERE is_verified = 1;  -- Same as TRUE
```

---

### **E) BINARY DATA TYPES**

| Type             | Max Size     | Use Case             |
| ---------------- | ------------ | -------------------- |
| **BINARY(n)**    | 255 bytes    | Fixed binary data    |
| **VARBINARY(n)** | 65,535 bytes | Variable binary data |
| **BLOB**         | 65,535 bytes | Images, files        |
| **MEDIUMBLOB**   | 16 MB        | Larger files         |
| **LONGBLOB**     | 4 GB         | Videos, huge files   |

**Example:**

```sql
CREATE TABLE Documents (
    doc_id INT PRIMARY KEY,
    file_name VARCHAR(255),
    file_data LONGBLOB,           -- Store actual file
    thumbnail BLOB                -- Store small image
);
```

**Best Practice:** Usually, store files on disk and only keep file paths in database:

```sql
CREATE TABLE Documents (
    doc_id INT PRIMARY KEY,
    file_name VARCHAR(255),
    file_path VARCHAR(500)        -- /uploads/documents/file.pdf
);
```

---

### **F) SPECIAL DATA TYPES**

#### **1. ENUM (Enumeration)**

- **Definition:** A string object that can have only ONE value from a list of predefined values

**Example:**

```sql
CREATE TABLE Orders (
    order_id INT PRIMARY KEY,
    status ENUM('pending', 'processing', 'shipped', 'delivered', 'cancelled')
);

-- Valid:
INSERT INTO Orders VALUES (1, 'pending');
INSERT INTO Orders VALUES (2, 'shipped');

-- Invalid (will cause error):
INSERT INTO Orders VALUES (3, 'unknown');
```

**Advantages:**

- Ensures data consistency
- Saves storage space
- Fast comparisons

---

#### **2. SET**

- **Definition:** Can hold ZERO or more values from a predefined list

**Example:**

```sql
CREATE TABLE Users (
    user_id INT PRIMARY KEY,
    interests SET('sports', 'music', 'reading', 'gaming', 'cooking')
);

-- Can select multiple:
INSERT INTO Users VALUES (1, 'sports,music,gaming');
INSERT INTO Users VALUES (2, 'reading');
INSERT INTO Users VALUES (3, '');  -- Empty set
```

---

#### **3. JSON**

- **Definition:** Stores JSON (JavaScript Object Notation) data
- **Use Case:** Flexible, semi-structured data

**Example:**

```sql
CREATE TABLE Products (
    product_id INT PRIMARY KEY,
    name VARCHAR(100),
    attributes JSON
);

INSERT INTO Products VALUES (
    1,
    'Laptop',
    '{"brand": "Dell", "ram": "16GB", "storage": "512GB SSD"}'
);

-- Query JSON data:
SELECT name, attributes->'$.brand' AS brand
FROM Products;
```

---

### **How to Choose the Right Data Type:**

1. **For IDs:** INT (or BIGINT for large tables)
2. **For Names/Text:** VARCHAR(appropriate length)
3. **For Money:** DECIMAL(10,2)
4. **For Dates:** DATE (just date) or DATETIME (date + time)
5. **For Yes/No:** BOOLEAN
6. **For Status:** ENUM
7. **For Small Numbers (0-255):** TINYINT
8. **For Large Text:** TEXT or LONGTEXT
9. **For Files:** Usually store path as VARCHAR, not the file itself

---

### **Common Mistakes to Avoid:**

❌ Using VARCHAR(255) for everything (wastes space)
✅ Use appropriate length: VARCHAR(50) for names, VARCHAR(100) for emails

❌ Using FLOAT for money (rounding errors)
✅ Use DECIMAL(10,2) for money

❌ Using VARCHAR for dates
✅ Use DATE, DATETIME, or TIMESTAMP

❌ Storing files in database
✅ Store file path, keep files on disk

---

## **3. CRUD OPERATIONS**

### **What is CRUD?**

CRUD stands for the four basic operations you can perform on database data:

- **C**reate (INSERT) - Add new data
- **R**ead (SELECT) - Retrieve data
- **U**pdate (UPDATE) - Modify existing data
- **D**elete (DELETE) - Remove data

These are the foundation of all database interactions.

---

### **A) CREATE - Adding Data (INSERT)**

#### **Basic Syntax:**

```sql
INSERT INTO table_name (column1, column2, column3)
VALUES (value1, value2, value3);
```

#### **Examples:**

**1. Insert Single Row:**

```sql
INSERT INTO Students (student_id, name, email, age)
VALUES (1, 'John Doe', 'john@email.com', 20);
```

**2. Insert Without Specifying Columns (must provide ALL values in order):**

```sql
INSERT INTO Students
VALUES (2, 'Jane Smith', 'jane@email.com', 22);
```

**3. Insert Multiple Rows at Once:**

```sql
INSERT INTO Students (student_id, name, email, age)
VALUES
    (3, 'Alice Brown', 'alice@email.com', 21),
    (4, 'Bob Wilson', 'bob@email.com', 23),
    (5, 'Charlie Davis', 'charlie@email.com', 20);
```

**4. Insert with Some Columns (others get default values):**

```sql
INSERT INTO Students (student_id, name)
VALUES (6, 'David Lee');
-- email and age will be NULL or default values
```

**5. Insert Data from Another Table:**

```sql
INSERT INTO ArchivedStudents (student_id, name, email)
SELECT student_id, name, email
FROM Students
WHERE graduation_year = 2024;
```

---

### **B) READ - Retrieving Data (SELECT)**

#### **Basic Syntax:**

```sql
SELECT column1, column2
FROM table_name
WHERE condition;
```

#### **Examples:**

**1. Select All Columns:**

```sql
SELECT * FROM Students;
```

**2. Select Specific Columns:**

```sql
SELECT name, email FROM Students;
```

**3. Select with Condition:**

```sql
SELECT name, age
FROM Students
WHERE age > 21;
```

**4. Select with Multiple Conditions:**

```sql
SELECT name, email
FROM Students
WHERE age >= 20 AND age <= 25;
```

**5. Select Distinct Values (no duplicates):**

```sql
SELECT DISTINCT age FROM Students;
```

**6. Select with Sorting:**

```sql
-- Ascending order (default)
SELECT name, age
FROM Students
ORDER BY age;

-- Descending order
SELECT name, age
FROM Students
ORDER BY age DESC;

-- Multiple columns
SELECT name, age
FROM Students
ORDER BY age DESC, name ASC;
```

**7. Select with Limit:**

```sql
-- Get first 5 students
SELECT * FROM Students LIMIT 5;

-- Skip first 10, then get 5 (pagination)
SELECT * FROM Students LIMIT 5 OFFSET 10;
```

**8. Select with Pattern Matching:**

```sql
-- Names starting with 'J'
SELECT * FROM Students WHERE name LIKE 'J%';

-- Names ending with 'son'
SELECT * FROM Students WHERE name LIKE '%son';

-- Names containing 'oh'
SELECT * FROM Students WHERE name LIKE '%oh%';

-- Names with exactly 4 characters
SELECT * FROM Students WHERE name LIKE '____';
```

**9. Select with NULL Check:**

```sql
-- Students without email
SELECT * FROM Students WHERE email IS NULL;

-- Students with email
SELECT * FROM Students WHERE email IS NOT NULL;
```

**10. Select with Range:**

```sql
-- Age between 20 and 25
SELECT * FROM Students WHERE age BETWEEN 20 AND 25;

-- NOT between
SELECT * FROM Students WHERE age NOT BETWEEN 20 AND 25;
```

**11. Select with List:**

```sql
-- Age is either 20, 22, or 24
SELECT * FROM Students WHERE age IN (20, 22, 24);

-- NOT in list
SELECT * FROM Students WHERE age NOT IN (20, 22, 24);
```

---

### **C) UPDATE - Modifying Data**

#### **Basic Syntax:**

```sql
UPDATE table_name
SET column1 = value1, column2 = value2
WHERE condition;
```

**⚠️ IMPORTANT:** Always use WHERE clause! Without it, ALL rows will be updated.

#### **Examples:**

**1. Update Single Row:**

```sql
UPDATE Students
SET email = 'newemail@email.com'
WHERE student_id = 1;
```

**2. Update Multiple Columns:**

```sql
UPDATE Students
SET email = 'updated@email.com', age = 23
WHERE student_id = 2;
```

**3. Update Multiple Rows:**

```sql
-- Increase age by 1 for all students older than 20
UPDATE Students
SET age = age + 1
WHERE age > 20;
```

**4. Update All Rows (USE CAREFULLY!):**

```sql
UPDATE Students
SET status = 'active';
-- This updates ALL students
```

**5. Update Using Calculation:**

```sql
UPDATE Products
SET price = price * 1.10
WHERE category = 'Electronics';
-- Increase price by 10%
```

**6. Update with Subquery:**

```sql
UPDATE Students
SET status = 'graduated'
WHERE student_id IN (
    SELECT student_id FROM Enrollments WHERE completion_date IS NOT NULL
);
```

---

### **D) DELETE - Removing Data**

#### **Basic Syntax:**

```sql
DELETE FROM table_name
WHERE condition;
```

**⚠️ DANGER:** Without WHERE clause, ALL rows will be deleted!

#### **Examples:**

**1. Delete Single Row:**

```sql
DELETE FROM Students
WHERE student_id = 5;
```

**2. Delete Multiple Rows:**

```sql
DELETE FROM Students
WHERE age < 18;
```

**3. Delete All Rows (DANGEROUS!):**

```sql
DELETE FROM Students;
-- Deletes ALL students, but keeps table structure
```

**4. Delete with Subquery:**

```sql
DELETE FROM Students
WHERE student_id IN (
    SELECT student_id FROM Suspensions WHERE suspension_date < '2024-01-01'
);
```

**5. Delete with JOIN:**

```sql
DELETE Students
FROM Students
INNER JOIN Enrollments ON Students.student_id = Enrollments.student_id
WHERE Enrollments.course_id = 101;
```

---

### **CRUD - Complete Example:**

```sql
-- CREATE (INSERT)
INSERT INTO Products (product_id, name, price, stock)
VALUES (1, 'Laptop', 50000, 10);

-- READ (SELECT)
SELECT name, price FROM Products WHERE stock > 5;

-- UPDATE
UPDATE Products
SET price = 48000, stock = 8
WHERE product_id = 1;

-- DELETE
DELETE FROM Products WHERE stock = 0;
```

---

### **Best Practices for CRUD:**

✅ **Always use WHERE clause** in UPDATE and DELETE
✅ **Test with SELECT first** - before UPDATE/DELETE, run SELECT with same WHERE clause to see what will be affected
✅ **Use transactions** for critical operations
✅ **Create backups** before bulk updates/deletes
✅ **Validate data** before INSERT
✅ **Use appropriate data types**
✅ **Index frequently queried columns**

---

### **Safety Pattern - Always Test First:**

```sql
-- SAFE WAY:

-- Step 1: First, SELECT to see what will be affected
SELECT * FROM Students WHERE age < 18;

-- Step 2: If results look correct, then UPDATE
UPDATE Students SET status = 'minor' WHERE age < 18;

-- Step 3: Verify the update
SELECT * FROM Students WHERE age < 18;
```

---

Would you like me to continue with **Section 4: SQL QUERIES (Advanced SELECT operations)** next? This section will cover:

- WHERE vs HAVING
- GROUP BY and ORDER BY
- UNION and UNION ALL
- Subqueries (correlated vs non-correlated)
- Aggregate functions (MIN, MAX, AVG, LIKE, COUNT)

Let me know if you'd like me to continue, or if you'd like any clarification on the CRUD operations first!
